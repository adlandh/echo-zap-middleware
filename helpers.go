package echozapmiddleware

import (
	"bytes"
	"io"

	"github.com/adlandh/response-dumper"
	"github.com/labstack/echo/v4"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

func prepareReqAndResp(c echo.Context, config ZapConfig) (*response.Dumper, []byte) {
	var respDumper *response.Dumper

	var reqBody []byte

	req := c.Request()

	if config.IsBodyDump {
		if req.Body != nil {
			var err error

			reqBody, err = io.ReadAll(req.Body)
			if err == nil {
				_ = req.Body.Close()
				req.Body = io.NopCloser(bytes.NewBuffer(reqBody)) // reset original request body
			}
		}

		respDumper = response.NewDumper(c.Response())
		c.Response().Writer = respDumper
	}

	return respDumper, reqBody
}

func limitString(config ZapConfig, str string) string {
	if !config.LimitHTTPBody || len(str) <= config.LimitSize {
		return str
	}

	return str[:config.LimitSize-3] + "..."
}

func getRequestID(ctx echo.Context) string {
	requestID := ctx.Request().Header.Get(echo.HeaderXRequestID) // request-id generated by reverse-proxy
	if requestID == "" {
		// missed request-id from proxy, got generated one by middleware.RequestID()
		requestID = ctx.Response().Header().Get(echo.HeaderXRequestID)
	}

	return requestID
}

func log(status int, logger *zap.Logger, fields []zapcore.Field) {
	switch {
	case status >= 500:
		logger.Error("Server error", fields...)
	case status >= 400:
		logger.Warn("Client error", fields...)
	case status >= 300:
		logger.Info("Redirection", fields...)
	default:
		logger.Info("Success", fields...)
	}
}
